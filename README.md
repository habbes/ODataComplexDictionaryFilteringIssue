# Filtering nested dynamic properties of complex types in OData

This repository provides solutions/workarounds for the issue [described here](https://github.com/OData/AspNetCoreOData/issues/1288).
Namely, it demonstrates how get OData filters based on nested dynamic properties to work with EF Core. We demonstrate solutions
for SQLite and Postgres.

The sample code defines an entity `Customer` which complex property `Name`. `Name` is of the complex, open type `LocalizableString`.

The custom `LocalizableString` provides a convenient way for string multiple translations of a string. You can store dynamic
key-value pairs representing different translations, e.g. `en` => `road`, `fr` => `route`. Based on the AspNetCoreOData convention,
the dynamic properties are backed by a `Dictionary<string, object>` property of the type. In this sample, the internal dictionary
property is called `ExtendedProperties`:

```csharp
class LocalizableString
{
    public IDictionary<string, object> ExtendedProperties
    {
        // ...
    }
}
```

However, in the database, the property is stored as a JSON object, e.g:

| ID  | `Name` |
|-----|--------|
| 1   | `{ "en": "Peter", "fr": "Pierre" }` |

Notice that in this setup, we don't map the `ExtendedProperties` to a database column, instead
we store the contents of this property directly in the `Name` column. This is important.

We want to be able to execute OData queries based these dynamic properties, namely the `$filter` query,
since that turns out to be problematic with the setup described above. More concretely, we want to find
customers based on a localized value of their names:

```http
GET /odata/customers?$filter=name/en eq 'Peter'
```

We use AspNetCoreOData with EF Core. I've experimented with both SQLite and Postgres based on reported issues.
It turns out this doesn't work out of the box with these (and probably other) SQL databases.

EF Core throws an exception revealing that it cannot translate the expression trees generated by AspNetCoreOData
into SQL.

For the query above, AspNetCoreOData generates an expression roughly equivalent to:

```c#
Customers.Where(c => (c.Name.ExtendedProperties.ContainsKey('en') ? c.Name.ExtendedProperties['en'] : null) == 'Peter')
```

My assumption for why this fails is that EF Core doesn't know how to map this `c.Name.ExtendedProperties` to a database column.

The solution we provide in this sample is to create a customer `IFilterBinder` that generates an expression tree that EF Core
knows how to translate. Since the column stores JSON data, we can leverage native JSON extraction functions of the underlying
database.

## How to run the project

- Decide whether you want to test with SQLite or Postgres (if using Postgres then you should setup the DB locally and update the connection string in [`TestDbContext`](./TestDbContext) if necessary)
- Set the `DbKind` field in the [`appsettings`](./ODataBug/appsettings.json`) to the database you want to test (`sqlite`, `postgres`, `memory`)
- We have two `FilterBinder` implementations: [`SQliteCustomFilterBinder`](./ODataDebug/SQliteCustomFilterBinder.cs) and [`PostgresCustomFilterBinder`](./ODataBug/PostgresCustomerFilterBinder.cs). You should enable the correct one in [`TestDbContext`](./ODataBug/TestDbContext.cs) using comments as appropriate.

## Steps of the solution
